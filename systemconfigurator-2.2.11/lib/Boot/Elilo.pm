package Boot::Elilo;

#   $Header$

#   Copyright (c) 2001 International Business Machines

#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
 
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#   dann frazier <dannf@ldl.fc.hp.com>
#   based on code by:  Donghwa John Kim <johkim@us.ibm.com>

#   Elilo caveats:
#   the kernel path names in elilo.conf (and therefore in systemconfig.conf)
#   must be relative to the efipartition, and apparently in efi syntax.

#   i.e.:

#   image=/boot/efi/vmlinuz         BAD
#   image=vmlinuz                   GOOD
#   image=/vmlinuz                  BAD
#   image=\vmlinuz                  GOOD
    

=head1 NAME

Boot::Elilo - Elilo bootloader configuration module.

=head1 SYNOPSIS

  my $bootloader = new Boot::Elilo(%bootvars);

  if($bootloader->footprint()) {
      $bootloader->setup();
  }

  my @fileschanged = $bootloader->files();

=cut

use strict;
use Carp;
use vars qw($VERSION);
use Boot;
use Util::Log qw(:all);
use Util::Cmd qw(:all);

$VERSION = sprintf("%d", q$Revision: 664 $ =~ /(\d+)/);

push @Boot::boottypes, qw(Boot::Elilo);

sub new {
    my $class = shift;
    my %this = (
                root => "",
                filesmod => [],
		bootloader_exe =>"/usr/sbin/elilo",
		boot_bootdev => "",
                boot_timeout => 50,
                @_,
                config_file => "/etc/elilo.conf",
               );

    $this{bootloader_exe} = $this{root} . $this{bootloader_exe};
    $this{config_file} = $this{root} . $this{config_file};
    
    bless \%this, $class;
}

=head1 METHODS

The following methods exist in this module:

=over 4

=item files()

The files() method is merely an accessor method for the all files
touched by the instance during its run.

=cut

sub files {
    my $this = shift;
    return @{$this->{filesmod}};
}

=item footprint()

This method returns 1 if Elilo bootloader is installed. 

=cut

sub footprint_config {
    my $this = shift;
    return -e $$this{config_file};
}

sub footprint_loader {
    my $this = shift;
    return -e $$this{bootloader_exe};
}

=item setup_config()

This method read the System Configurator's config file and translates it
into the bootloader's "native" config file. 

=cut

sub install_config {
    my $this = shift;

    if(!$$this{boot_defaultboot}) 
    {
	croak("Error: DEFAULTBOOT must be specified.\n");;
    }

    open(OUT,">$$this{config_file}") or croak("Couldn\'t open $$this{config_file} for writing");
    print OUT <<ELILOCONF;
##################################################
# This file is generated by System Configurator. #
##################################################

# The number of deciseconds (0.1 seconds) to wait before booting
install=/usr/lib/elilo/elilo.efi
delay=$$this{boot_timeout}
boot=$$this{boot_bootdev}

# the default label to boot
default=$$this{boot_defaultboot}

ELILOCONF
  
  # Now we append the items that may have not been there previously
  
#    if ($this->{boot_rootdev}) {
#        print OUT "# Device to be mounted as the root ('/') \n";
#        print OUT "root=" . $this->{boot_rootdev} . "\n";
#    }
##    if ($this->{boot_append}) {
 #       print OUT "# Kernel command line options. \n";
 #       print OUT "append=" . $this->{append} . "\n";
 #   }
    
    foreach my $key (sort keys %$this) {
        if ($key =~ /^(kernel\d+)_path/) {
            $this->setup_kernel($1,\*OUT);
        }
    }
    
    close(OUT);

    push @{$this->{filesmod}}, "$$this{config_file}";
    1;
}

=item setup_kernel()

An "internal" method.
This method sets up a kernel image as specified in the config file.

=cut

sub setup_kernel {
    my ($this, $kernel, $outfh) = @_;
    
    if ($$this{$kernel . "_label"} eq $$this{boot_defaultboot}) {
	unless ($$this{boot_rootdev} || $$this{$kernel . "_rootdev"}) {
	    croak("ROOTDEV must be specified either globally or locally.");
	    close($outfh);
	}
    }
    
    my $image = $$this{$kernel . "_path"};

    print $outfh <<LILOCONF;
#----- Options for \U$kernel\E -----#
image=$image
\tlabel=$$this{$kernel . "_label"}
\tread-only
LILOCONF

    ### Check for command line kernel options. 
    if ($this->{$kernel . "_append"}) {
	print $outfh "\tappend=" . "\"" . $this->{$kernel . "_append"} . "\"" . "\n";
    }

    ### Override global rootdev option?
    if ($this->{$kernel. "_rootdev"}) {
        print $outfh "\troot=" . $this->{$kernel . "_rootdev"} . "\n";
    }    

    ### Initrd image
    if ($this->{$kernel. "_initrd"}) {
        print $outfh "\tinitrd=" . $this->{root} . $this->{$kernel . "_initrd"} . "\n";
    }        
}

#   Elilo caveats:
#   the kernel path names in elilo.conf (and therefore in systemconfig.conf)
#   must be relative to the efipartition, and apparently in efi syntax.

#   i.e.:

#   image=/boot/efi/vmlinuz         BAD
#   image=vmlinuz                   GOOD
#   image=/vmlinuz                  BAD
#   image=\vmlinuz                  GOOD


sub install_loader {
    my $this = shift;
    my $e = $$this{bootloader_exe};
    if($$this{root}) {
        if($e =~ /^($$this{root})(.*)/) {
            my $cmd = $2;
            return !system("chroot $$this{root} $cmd --format --efiboot");
        } 
        return undef;
    } else {
        return !system("$e --format --efiboot");
    }
}

=back

=head1 AUTHOR

  dann frazier <dannf@ldl.fc.hp.com>
  sean dague <sean@dague.net>

=head1 SEE ALSO

L<Boot>, L<perl>

=cut

1;




















